**目录**

- [2. 客户端注册](#2-客户端注册)
  - [2.1. 客户端类型](#21-客户端类型)
  - [2.2. 客户端标识符](#22-客户端标识符)
  - [2.3. 客户端重定向端点](#23-客户端重定向端点)
    - [2.3.1. 注册要求](#231-注册要求)
    - [2.3.2. 多个重定向 URI](#232-多个重定向-uri)
    - [2.3.3. 防止 CSRF 攻击](#233-防止-csrf-攻击)
    - [2.3.4. 防止混淆攻击](#234-防止混淆攻击)
    - [2.3.5. 无效端点](#235-无效端点)
    - [2.3.6. 端点内容](#236-端点内容)
  - [2.4. 客户端认证](#24-客户端认证)
    - [2.4.1. 客户端密钥](#241-客户端密钥)
    - [2.4.2. 其它认证方法](#242-其它认证方法)
  - [2.5. 未注册的客户端](#25-未注册的客户端)

# 2. 客户端注册

在启动协议之前，客户端必须在授权服务器上进行注册。这种注册的方式超出了该规范的范围，但通常需要客户端的开发人员在授权服务器的网站上创建账户、同意服务条款并手动注册客户端，或者使用客户端动态注册（[RFC7591](https://www.rfc-editor.org/info/rfc7591)）。

客户端注册不需要客户端和授权服务器直接进行交互。如果授权服务器支持，注册可以靠其它方法来建立信任，并且获取必需的客户端属性（例如重定向 URI、客户端类型）。例如，注册可以通过自我签发或者第三方签发的声明来完成，或者让授权服务器通过可信渠道发现客户端。

当注册客户端时，客户端的开发人员**要**：

- 如第 2.1 节所述，指定客户端的类型。
- 按照正在使用的许可类型，提供其所需的客户端详情，例如如第 2.3 节所述的重定向 URI。
- 包含授权服务器要求的任何其它信息（例如应用名称、网站地址、描述、logo 图片、对法律条款的接受）。

客户端动态注册（[[RFC7591](https://www.rfc-editor.org/info/rfc7591)]）定义了一种常见且通用的客户端数据模型，其同样也可以用于客户端的手动注册。

## 2.1. 客户端类型

OAuth 2.1 根据客户端与授权服务器进行安全认证的能力，定义了两种客户端类型。

**“机密”：** 与授权服务器共享凭据的客户端被称为“机密客户端”。

**“公开”：** 没有凭据的客户端被称为“公开客户端”。

任何拥有凭据的客户端**必须**采取预防措施，防止它们的凭据被泄露或滥用。

客户端认证使得授权服务器在 OAuth 流程中，能够确保它在与某一特定客户端交互（通过后者的 client_id 辨认）。授权服务器会做出一系列决策，例如是在每次授权时都提醒用户，还是因为确信“自己确实在与合法客户端通信”，所以只在第一次时提醒用户。

对于客户端的身份，或者是该客户端的提供方/操作方的身份，授权服务器是否验证、如何验证，超出了该规范的范围。在决定是否允许客户端访问更敏感的资源和操作（例如客户端凭据授权类型）时，以及决定提醒用户同意的频率时，授权服务器**应该**考虑对客户端身份的确信程度。

一个 client_id **不应该**被视为多种类型的客户端。

该规范针对以下客户端形式进行了设计：

**“网络应用”：** 网络应用是运行在网络服务器上的客户端。资源所有者在他使用的设备上，通过用户代理渲染的 HTML 用户界面，访问客户端。客户端凭证，以及颁发给客户端的访问令牌，都被储存在网络服务器上，不暴露给资源所有者，也无法被资源所有者访问。

**“浏览器应用”：** 浏览器应用是从网络服务器下载代码，并在用户代理（例如浏览器）中运行的客户端。资源所有者能够轻易访问（并且经常能看到）协议的数据和凭据。如果这种应用希望使用客户端凭据，那么推荐其为前端配备一个后端。由于这种应用运行在用户代理中，它们在请求授权时，可以丝滑地发挥用户代理的能力。

**“原生应用”：** 原生应用是安装并运行在资源管理者的设备上的程序。资源所有者能够访问协议的数据和凭据。假设应用程序中包含的任何客户端认证凭据都可以被提取。动态颁发的访问令牌和刷新令牌可以获得可接受级别的保护。在某些平台上，这些凭据受到同设备上其它应用的保护。如果这种应用希望使用客户端凭据，那么推荐其为前端配备一个后端，或者使用客户端动态注册（[[RFC7591](https://www.rfc-editor.org/info/rfc7591)]）在运行时颁发凭据。

## 2.2. 客户端标识符

在授权服务器上，每个客户端的标识都依靠一个客户端标识符，即一个代表客户端提供的注册信息的唯一字符串。虽然授权服务器通常是自己颁发客户端标识符，但它也可以服务那些由其它方颁发标识符的客户端。客户端标识符不是一个秘密；它被暴露给资源所有者，并且**禁止**仅使用客户端标识符来认证客户端。在授权服务器上，客户端标识符是唯一的。

客户端标识符是一个不透明的字符串，其大小在该规范中没有定义。客户端应该避免假设标识符大小。授权服务器**应该**记录其颁发的任何标识符的大小。

如果授权服务器支持由其它方颁发标识符的客户端，那么授权服务器**应该**采取预防措施，防止客户端冒充资源所有者，如第 7.4 节所述。

## 2.3. 客户端重定向端点

客户端重定向端点（也被称为“重定向端点”）是授权服务器在与资源所有者完成交互后，将用户代理重定向回到的客户端 URI。

在客户端注册的过程中，客户端预先与授权服务器上建立了一系列客户端重定向端点。授权服务器将用户代理重定向到这些端点中的其一。

重定向 URI **必须**是由 [[RFC3986](https://www.rfc-editor.org/info/rfc3986)] 第 4.3 节定义的绝对 URI。重定向 URI **可以**包含一个 application/x-www-form-urlencoded 格式的查询部分（[[WHATWG.URL](https://url.spec.whatwg.org/)]），在添加额外的查询参数时**必须**保留该部分。重定向 URI **禁止**包含片段部分。

### 2.3.1. 注册要求

授权服务器**必须**要求客户端注册它们的完整重定向 URI（包括路径部分）。授权服务器**必须**拒绝指定的重定向 URI 与注册的 URI 不精确匹配的授权请求。但对于回环重定向，URI 端口部分可以不精确匹配，详见第 4.1.1 节。

授权服务器**可以**允许客户端注册多个重定向 URI。

注册可以不使用网络通信进行，例如在授权服务器上手动配置客户端信息，或者也可以在运行时进行，例如推送授权请求 [[RFC9126](https://www.rfc-editor.org/info/rfc9126)] 中的初始 POST 请求。

对于基于私用 URI 方案的重定向 URI，授权服务器**应该**执行第 8.4.3 节的要求，也就是客户端需要使用基于反向域名的方案。至少，任何不包含句号（.）的私用 URI 方案都**应该**被拒绝。

除了抗碰撞属性外，这还可以在发生特定争议时帮助证明所有权，争议中的两个应用程序声称使用相同的私用 URI 方案（其中一个应用程序是恶意行为）。例如，如果两个应用程序声称使用 com.example.app，example.com 的所有者可以向应用商店运营商申请移除伪造的应用程序。如果使用通用 URI 方案，则更难以证明此类申请。

客户端**禁止**暴露如 7.12 节所述的，将用户浏览器转发到查询参数中的任意 URI 的 URL（开放式重定向 URL）。这种 URL 可能导致授权码和访问令牌的渗透。

客户端**可以**使用 state 查询参数，以按需定制每个请求，而非改变每个请求的重定向 URI。

如果不要求注册重定向 URI，攻击者就可以将授权端点作为开放式重定向 URL，如第 7.12 节所述。

### 2.3.2. 多个重定向 URI

如果客户端注册了多个重定向 URI，那么客户端**必须**在授权请求中使用 redirect_uri 请求参数（第 4.1.1 节）包含目标重定向 URI。如果客户端只注册了一个重定向 URI，redirect_uri 请求参数就是可选的。

### 2.3.3. 防止 CSRF 攻击

客户端**必须**预防跨站请求伪造（CSRF）攻击。在这一语境中，CSRF 指请求的重定向端点不来自授权服务器，而是来自恶意的第三方（详见 [[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 的第 4.4.1.8 节）。已经确保授权服务器支持 code_challenge 参数的客户端**可以**依赖该机制提供的 CSRF 保护。在 OpenID Connect 流程中，验证 nonce 参数提供了 CSRF 保护。否则，**必须**使用 state 参数中携带的、与用户代理安全绑定的、一次性使用的 CSRF 令牌，以实现 CSRF 保护（见第 7.9 节）。

### 2.3.4. 防止混淆攻击

如果 OAuth 客户端只能够和一台授权服务器交互，那么混淆攻击防御不是必需的。但如果 OAuth 客户端和两台或多台授权服务器交互，那么客户端就**必须**防止混淆攻击。为了防止混淆攻击，客户端**必须**仅处理其发送相应请求的发行者的重定向响应，并且只能来自发起此授权请求的同一用户代理。

第 7.13 节详细描述了两种不同的混合攻击防御。

### 2.3.5. 无效端点

如果授权请求由于缺失、无效或不匹配的重定向 URI 而验证失败，授权服务器**应该**告知资源所有者该错误，并且**禁止**自动将用户代理重定向到无效的重定向 URI。

### 2.3.6. 端点内容

对客户端端点的重定向请求通常以 HTML 文档为响应，并由用户代理进行处理。如果 HTML 响应被直接作为重定向请求的结果，那么 HTML 文档中包含的任何脚本在执行时，都拥有重定向 URI 以及其中包含的内容（例如授权码）的完全访问权限。此外，包含授权码的请求 URL 可能会被携带在 HTTP Referer 头部中，发送给页面中加载的所有嵌入图像、样式表和其他元素。

客户端**不应该**在重定向 URI 端点响应中包含任何第三方脚本（例如第三方分析、社交插件、广告网络）。相反，它**应该**从 URI 中提取出内容，并将用户代理再次重定向到另一个端点，而不暴露其中的内容（无论是在 URI 中还是其他地方）。如果包含了第三方脚本，客户端**必须**确保自己的（用于从 URI 中提取和移除凭证的）脚本会首先执行。

## 2.4. 客户端认证

如果颁发/注册和分发凭证的过程能够确保凭证的机密性，授权服务器**必须**只依赖于客户端认证。

如果客户端是机密的，授权服务器**可以**接受满足其安全要求（例如密码、公钥/私钥对）的任何形式的客户端认证。

**推荐**使用非对称（基于公钥）的客户端认证方法，例如 mTLS [[RFC8705](https://www.rfc-editor.org/info/rfc8705)] 或符合 [[RFC7521](https://www.rfc-editor.org/info/rfc7521)] 和 [[RFC7523](https://www.rfc-editor.org/info/rfc7523)] 要求的、使用签名的 JWT（"私钥 JWT"）（在 [[OpenID](https://openid.net/specs/openid-connect-core-1_0.html)] 中被定义为客户端认证方法 private_key_jwt）。当使用这些客户端认证方法时，授权服务器不需要存储敏感的对称密钥，使得这些方法对许多攻击更加健壮。

当无法进行客户端认证时，授权服务器**应该**采用其他方法来验证客户端的身份——例如要求客户端注册重定向 URI ，或者询问资源所有者来确认身份。仅仅拥有有效的重定向 URI 不足以在请求资源所有者授权时验证客户端的身份，但可以在获得资源所有者的授权后，用于防止将凭证交付给伪造的客户端。

客户端**禁止**在单个请求中使用多种认证方法，以避免认证机制权威性的冲突。

授权服务器**必须**考虑与未认证客户端交互的安全影响，并采取措施限制给这种客户端颁发的令牌的潜在曝光（例如限制刷新令牌的生命周期）。

授权服务器为某一客户端身份所关联的权限**必须**取决于对客户端标识符和客户端凭证生命周期管理的整体过程的评估。详见第 7.2 节。

### 2.4.1. 客户端密钥

持有客户端密钥（有时也被称为客户端密码）的客户端**可以**使用 [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 第 11 节中定义的 HTTP 基本认证方案，与授权服务器进行认证。客户端标识符使用附录 B 中的 application/x-www-form-urlencoded 编码算法进行编码，编码后的值用作用户名。客户端密钥也使用相同的算法进行编码，并用作密码。授权服务器**必须**支持使用 HTTP 基本认证方案来认证被颁发了客户端密钥的客户端。

例如（额外的换行符仅为展示目的）：

```
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
```

除此之外，授权服务器**可以**支持在请求内容中包含客户端凭证，使用以下参数：

**"client_id":** **必需**。在第 2.2 节描述的注册过程中，颁发给客户端的客户端标识符。

**"client_secret":** **必需**。客户端密钥。

在请求内容中使用这两个参数来包含客户端凭证是**不推荐**的，并且**应该**被限制在无法直接使用 HTTP 基本认证方案（或其他基于密码的 HTTP 认证方案）的客户端上。这些参数只能在请求内容中传输，**禁止**包含在请求URI中。

例如，使用内容参数刷新访问令牌（第4.3节）的请求（为了显示目的添加了额外的换行符）：

```
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
```

由于这种客户端认证方法涉及密码，授权服务器**必须**保护使用这种方法的任何端点免受暴力破解攻击。

### 2.4.2. 其它认证方法

授权服务器**可以**支持任何符合其安全要求的合适的认证方案。当使用其它认证方案时，授权服务器**必须**定义从客户端标识符（注册记录）到认证方案的映射。

一些其它的认证方法，例如 mTLS [[RFC8705](https://www.rfc-editor.org/info/rfc8705)] 和私钥 JWT [[RFC7523](https://www.rfc-editor.org/info/rfc7523)]，在文档[《OAuth 令牌端点认证方法》](https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-endpoint-auth-method)中进行了定义。它们可以用作通用的客户端认证方法，而不仅仅是保护令牌端点。

## 2.5. 未注册的客户端

该规范不要求客户端必须在授权服务器上注册。然而，使用未注册的客户端超出了本规范的范围，并且需要额外对其互操作性影响进行安全分析和检查。
