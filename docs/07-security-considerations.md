**目录**

- [7. 安全考量](#7-安全考量)
  - [7.1. 访问令牌的安全考量](#71-访问令牌的安全考量)
    - [7.1.1. 安全威胁](#711-安全威胁)
      - [7.1.1.1. 访问令牌的生成或修改](#7111-访问令牌的生成或修改)
      - [7.1.1.2. 访问令牌的泄露](#7112-访问令牌的泄露)
      - [7.1.1.3. 访问令牌的重定向](#7113-访问令牌的重定向)
      - [7.1.1.4. 访问令牌的重放](#7114-访问令牌的重放)
    - [7.1.2. 减少威胁](#712-减少威胁)
    - [7.1.3. 建议总结](#713-建议总结)
      - [7.1.3.1. 保护 Bearer 令牌](#7131-保护-bearer-令牌)
      - [7.1.3.2. 验证 TLS 证书链](#7132-验证-tls-证书链)
      - [7.1.3.3. 始终使用 TLS（https）](#7133-始终使用-tlshttps)
      - [7.1.3.4. 不要在 HTTP cookies 里存储 Bearer 令牌](#7134-不要在-http-cookies-里存储-bearer-令牌)
      - [7.1.3.5. 颁发短期的 Bearer 令牌](#7135-颁发短期的-bearer-令牌)
      - [7.1.3.6. 颁发有限范围的 Bearer 令牌](#7136-颁发有限范围的-bearer-令牌)
      - [7.1.3.7. 不要在页面 URL 中传递 Bearer 令牌](#7137-不要在页面-url-中传递-bearer-令牌)
    - [7.1.4. 访问令牌的权限限制](#714-访问令牌的权限限制)
  - [7.2. 客户端认证](#72-客户端认证)
  - [7.3. 冒充客户端](#73-冒充客户端)
    - [7.3.1. 冒充原生应用](#731-冒充原生应用)
    - [7.3.2. 访问令牌的权限限制](#732-访问令牌的权限限制)
  - [7.4. 客户端冒充资源所有者](#74-客户端冒充资源所有者)
  - [7.5. 授权码的安全考量](#75-授权码的安全考量)
    - [7.5.1. 授权码注入](#751-授权码注入)
    - [7.5.2. 对策](#752-对策)
    - [7.5.3. 授权码的重用](#753-授权码的重用)
    - [7.5.4. HTTP 307 重定向](#754-http-307-重定向)
  - [7.6. 确保端点真实性](#76-确保端点真实性)
  - [7.7. 凭据预测攻击](#77-凭据预测攻击)
  - [7.8. 钓鱼攻击](#78-钓鱼攻击)
  - [7.9. 跨站请求伪造](#79-跨站请求伪造)
  - [7.10. 点击劫持](#710-点击劫持)
  - [7.11. 代码注入和输入验证](#711-代码注入和输入验证)
  - [7.12. 开放式重定向](#712-开放式重定向)
    - [7.12.1. 客户端作为开放式重定向器](#7121-客户端作为开放式重定向器)
    - [7.12.2. 授权服务器作为开放式重定向器](#7122-授权服务器作为开放式重定向器)
  - [7.13. 减少授权服务器混淆攻击](#713-减少授权服务器混淆攻击)
    - [7.13.1 基于颁发者身份的混淆攻击防御](#7131-基于颁发者身份的混淆攻击防御)
    - [7.13.2. 基于唯一重定向 URI 的混淆攻击防御](#7132-基于唯一重定向-uri-的混淆攻击防御)

# 7. 安全考量

作为一款灵活、可扩展的框架，OAuth 的安全考量取决于许多因素。下面各节针对第 2.1 节所述的三种客户端形式（网络应用、浏览器应用和原生应用），为实现者提供安全指南。

[[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 和 [[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-27)] 提供了全面的 OAuth 安全模型和分析，以及协议设计的背景。

## 7.1. 访问令牌的安全考量

### 7.1.1. 安全威胁

下面列出了几种针对使用某种形式令牌的协议的常见威胁。这些威胁基于 NIST 特别出版物 800-63 [[NIST800-63](http://csrc.nist.gov/publications/)]。

#### 7.1.1.1. 访问令牌的生成或修改

攻击者可能会生成一个假的访问令牌，或者修改现有令牌的内容（例如认证信息或属性声明），导致资源服务器给客户端授予了不恰当的访问权限。例如，攻击者可能会修改令牌，以延长其有效期。恶意客户端可能会修改陈述，以访问它们原本不能查看的信息。

#### 7.1.1.2. 访问令牌的泄露

访问令牌可能包含认证信息和属性声明，其中包含了敏感信息。

#### 7.1.1.3. 访问令牌的重定向

攻击者使用原定被一台资源服务器使用的访问令牌，访问另一台资源服务器，后者误认为访问令牌是被其使用的。

#### 7.1.1.4. 访问令牌的重放

攻击者试图使用过去已在该资源服务器上使用过的访问令牌。

### 7.1.2. 减少威胁

使用数字签名保护访问令牌的内容，可以减少许多威胁。

或者，Bearer 令牌可以包含对授权信息的引用，而不是直接编码这些信息。使用引用可能需要资源服务器和授权服务器进行一次额外互动，以将引用解析为授权信息。该规范美哦与定义这种互动的机制，但代码检查 [[RFC7662](https://www.rfc-editor.org/info/rfc7662)] 定义了一种此类机制。

该文档没有规定访问令牌的编码或内容。因此，关于保障访问令牌完整性的方法的详细建议超出了该规范的范围。访问令牌的 JWT 形式 [[RFC9068](https://www.rfc-editor.org/info/rfc9068)] 描述了访问令牌编码和签名机制的一个示例。

为了处理访问令牌的重定向，有一点很重要，即授权服务器在令牌中包含预期接收者（受众）的身份，后者通常是单台（或若干台）资源服务器。此外，还**建议**将访问令牌的使用限制在特定范围内。

如果传输 cookies 时没有 TLS 保护，那么其中包含的任何信息都有泄露的风险。因此，Bearer 令牌**禁止**被存储在可以被明文发送的 cookies 中。关于 cookies 的安全考量见《HTTP 状态管理机制》[[RFC6265](https://www.rfc-editor.org/info/rfc6265)]。

在某些部署（包括那些使用负载均衡的部署）中，与资源服务器的 TLS 连接会在实际提供资源的服务器之前终止。这可能导致，在 TLS 连接终止的前端服务器和提供资源的后端服务器之间，令牌不受保护。在这种部署中，**必须**采取足够的措施，确保前后端服务器之间的访问令牌机密性。令牌加密就是其中一种可能的措施。

### 7.1.3. 建议总结

#### 7.1.3.1. 保护 Bearer 令牌

客户端的实现**必须**确保 Bearer 令牌不会泄露给非预期方，因为后者可以使用这些令牌访问受保护资源。这是使用 Bearer 令牌时的首要安全考量，也是下面所有更具体建议的基础。

#### 7.1.3.2. 验证 TLS 证书链

当请求受保护资源时，客户端**必须**验证 TLS 证书链。不这么做可能会导致 DNS 劫持攻击窃取令牌，并且获取预期外的访问权限。

#### 7.1.3.3. 始终使用 TLS（https）

当使用 Bearer 令牌发起请求时，客户端**必须**始终使用 TLS，或者等效的传输层安全性协议。不这么做会将令牌暴露给数种攻击，让攻击者获取预期外的访问权限。

#### 7.1.3.4. 不要在 HTTP cookies 里存储 Bearer 令牌

具体实现**禁止**在可以被明文发送（cookies 的默认传输模式）的 cookies 中存储 Bearer 令牌。在 cookies 中存储 Bearer 令牌的具体实现**必须**采取措施预防跨站请求伪造。

#### 7.1.3.5. 颁发短期的 Bearer 令牌

授权服务器**应该**颁发短期的 Bearer 令牌，特别是在将令牌颁发给在网络浏览器中运行的客户端，或者其它可能发生信息泄露的环境时。使用短期的 Bearer 令牌可以减少其泄露的影响。

#### 7.1.3.6. 颁发有限范围的 Bearer 令牌

授权服务器**应该**颁发包含受众限制的 Bearer 令牌，将它们的范围限制在预期内的依赖方或依赖方集合。

#### 7.1.3.7. 不要在页面 URL 中传递 Bearer 令牌

Bearer 令牌**禁止**在页面 URL 中传递（例如，作为查询字符串参数），而**应该**在采取了保密措施的 HTTP 消息头或消息体中传递。浏览器、网络服务器以及其它软件可能无法充分保护浏览器历史记录、网络服务器日志以及其它数据结构中的 URL。如果 Bearer 令牌在 URL 中传递，那么攻击者就有可能从历史数据、日志或其它不安全的地方窃取令牌。

### 7.1.4. 访问令牌的权限限制

与访问令牌关联的权限**应该**被限制在特定应用或用例所需的最小范围内。这样可以防止客户端超出资源所有者授权的权限。它还能防止用户超出各自安全策略授权的权限。权限限制还有助于减少访问令牌泄漏的影响。

特别是，访问令牌**应该**被限制在特定的资源服务器上（受众限制），最好是单台资源服务器。为了实现这一点，授权服务器将访问令牌与特定的资源服务器关联起来，每台资源服务器都有义务验证每个请求，以确定随该请求发送的访问令牌是否用于该台特定的资源服务器。如果不是，资源服务器**必须**拒绝为相应请求提供服务。客户端和授权服务器**可以**利用该文档和 [[RFC8707](https://www.rfc-editor.org/info/rfc8707)] 分别规定的 scope 或 resource 参数，来确定要访问的资源服务器。

此外，访问令牌**应该**被限制在资源服务器或资源上的特定资源和特定操作。为了实现这一点，授权服务器将访问令牌与相应的资源和操作关联起来，每台资源服务器都有义务验证每个请求，以确定随该请求发送的访问令牌是否用于特定资源上的特定操作。如果不是，资源服务器**必须**拒绝为相应请求提供服务。客户端和授权服务器**可以**利用 [[RFC9396](https://www.rfc-editor.org/info/rfc9396)] 中规定的 scope 和 authorization_details 参数，来确定这些资源和/或操作。

## 7.2. 客户端认证

根据客户注册整体流程和凭据生命周期管理，这可能会影响授权服务器对特定客户的信任度。

例如，对动态注册的客户端的认证并不能证明客户端的身份，而只能确保对授权服务器的重复请求是由同一个客户端实例发出的。这种客户端可能在请求的允许范围方面受到限制，或者可能有其他限制，比如更短的令牌寿命。

相比之下，如果有一个已注册的应用程序，其开发者通过了身份验证，签署了合同，被颁发了客户端密钥，并且该密钥仅在安全后端服务中使用，那么授权服务器可能会允许该客户端请求更敏感的范围，或给它颁发更长期的令牌。

## 7.3. 冒充客户端

如果机密客户端的凭据被窃取，那么恶意客户端就可以冒充该客户端，获取对受保护资源的访问权限。

授权服务器应该强制执行明确的资源所有者认证，并且为其提供客户端信息，以及请求的授权范围和寿命。资源所有者可以根据当前客户端的情况审查这些信息，并授权或拒绝该请求。

授权服务器**不应该**在未认证客户端，或者未采取其它措施以确保重复请求来自原客户端而非冒充者的情况下，（在资源所有者没有主动交互时）自动处理重复的授权请求。

### 7.3.1. 冒充原生应用

如上所述，授权服务器**不应该**在未经用户同意或互动的情况下，自动处理授权请求，除非能确保客户端的身份。这也包括了用户以前批准过某个客户端 ID 的授权请求的情况——除非能证明客户端的身份，否则就**应该**像以前没有批准过请求一样，处理该请求。

授权服务器**可以**接受声明的 https 方案重定向等措施，作为身份证明。某些操作系统可能会提供其他平台特有的身份证明功能，这些功能**可以**被酌情接受。

### 7.3.2. 访问令牌的权限限制

客户端**应该**申请最小范围的访问令牌。授权服务器在选择如何顺应申请的范围时，**应该**考虑客户端身份，并且**可以**签发范围小于申请范围的访问令牌。

与访问令牌关联的权限**应该**被限制在特定应用或用例所需的最小范围内。这样可以防止客户端超出资源所有者授权的权限。它还能防止用户超出各自安全策略授权的权限。权限限制还有助于减少访问令牌泄漏的影响。

特别是，访问令牌**应该**被限制在特定的资源服务器上（受众限制），最好是单台资源服务器。为了实现这一点，授权服务器将访问令牌与特定的资源服务器关联起来，每台资源服务器都有义务验证每个请求，以确定随该请求发送的访问令牌是否用于该台特定的资源服务器。如果不是，资源服务器**必须**拒绝为相应请求提供服务。客户端和授权服务器**可以**利用该文档和 [[RFC8707](https://www.rfc-editor.org/info/rfc8707)] 分别规定的 scope 或 resource 参数，来确定要访问的资源服务器。

## 7.4. 客户端冒充资源所有者

资源服务器做出访问控制决策时，可能根据的是被颁发访问令牌的资源所有者的身份，或者是客户端凭据许可中客户端的身份。如果两种选择都可行，根据实现细节，客户端的身份可能会被误认为是资源所有者的身份。例如，如果客户端在授权服务器上注册时，可以选择自己的 client_id，那么恶意客户端可能会将其设置为终端用户的标识值（例如，使用 OpenID Connect 时的 sub 值）。如果资源服务器不能正确区分颁发给客户端的访问令牌和颁发给终端用户的访问令牌，客户端就有可能访问终端用户的资源。

如果客户端 ID 和用户标识符在授权服务器上处于同一个通用命名空间，导致资源服务器无法区分资源所有者授权的访问令牌和客户端自身授权的访问令牌，那么授权服务器就**不应该**允许客户端左右它们的 client_id 或任何其它声明，以免与真正的资源所有者造成混淆。当这种情况无法避免时，授权服务器**必须**为资源服务器提供其它方法，以区分这两种访问令牌。

## 7.5. 授权码的安全考量

### 7.5.1. 授权码注入

授权码注入是这样一种攻击，客户端在重定向 URI 中接收到了攻击者的授权代码，而不是合法授权服务器的授权代码。在没有保护措施的情况下，客户端没有办法知道攻击的发生。授权码注入既可能导致攻击者获取对受害者账户的访问权限，也可能导致受害者意外获取对攻击者账户的访问权限。

### 7.5.2. 对策

为防止向客户端注入授权码，code_challenge 和 code_verifier 的使用对于客户端而言是**必需**的。授权服务器也**必须**强制使用两者，除非同时满足下面两个条件：

- 客户端是机密客户端。
- 在特定部署和特定请求中，授权服务器能够合理保证客户端正确实现了 OpenID Connect 的验证码机制。

在这种情况下，仍然**建议**强制使用 code_challenge 和 code_verifier。

code_challenge 或 OpenID Connect 的 nonce 值**必须**针对特定事务，并与客户端和启动事务的用户代理安全绑定。如果事务出错，那么**必须**重新选择 code_challenge 或 nonce 值。

依靠客户端验证 OpenID Connect 的 nonce 参数意味着授权服务器无法确认客户端是否确实保护了自己免受授权码注入攻击。如果攻击者能够向客户端注入授权码，客户端仍会使用注入的授权码交换令牌。当之后验证 nonce 并发现其不匹配时，客户端才会拒绝 ID 令牌。相比之下，强制使用 code_challenge 和 code_verifier 参数的授权服务器提供了更高的安全性，因为授权服务器能够事先识别出授权码注入攻击，并从一开始就不颁发任何令牌。

历史原因说明：虽然 PKCE [[RFC7636](https://www.rfc-editor.org/info/rfc7636)]（code_challenge 和 code_verifier 参数最先在此提出）最初被设计为一种机制，用于保护原生应用免受授权码渗漏攻击，但是所有类型的 OAuth 客户端，包括网络应用和其它机密客户端，都容易受到授权码注入攻击。而 code_challenge 和 code_verifier 机制可以解决这个问题。

### 7.5.3. 授权码的重用

如果授权码能够被多次重用，那么可能发生多种攻击。

如第 4.1.3 节所述，当授权服务器接收到第二个有效的请求，并且其中包含的授权码已经被用于颁发访问令牌，那么授权服务器必须拒绝该令牌请求，并收回所有颁发的令牌。如果攻击者能够渗透授权码，并抢在合法客户端之前使用它，那么攻击者就能够获得访问令牌，而合法客户端则不能。收回所有颁发的令牌，意味着攻击者的令牌将被收回，阻止进一步的攻击。

然而，仅当这一包含授权码的请求同样有效（包括其它参数，例如 code_verifier 和客户端认证信息）时，授权服务器才应该收回颁发的令牌。当接收到包含无效参数的重放授权码时，授权服务器**不应该**收回任何颁发的令牌。如果这样做，那么那些能够获取授权码、但无法获取客户端认证信息或 code_verifier 的攻击者，就可以抢在合法客户端之前发送无效的授权码请求，从而在合法客户机发出有效请求后收回其令牌。

### 7.5.4. HTTP 307 重定向

授权服务器在重定向可能包含用户凭据的请求时，**禁止**使用 307 状态码（[[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 第 15.4.8 节）进行重定向。如果这种请求使用的是 HTTP 重定向（而非，例如，JavaScript），授权服务器**应该**使用状态码 303（见别处）。

在授权端点上，典型的协议流程是：授权服务器促使用户在表单中输入他们的凭据，然后表单被（通过 POST 方法）提交回到授权服务器。授权服务器检查凭据，如果成功，那么将用户代理重定向到客户端的重定向 URI。

如果重定向使用的是状态码 307，那么用户代理就会通过 POST 请求，将用户凭据发送给客户端。

这会将敏感凭据泄露给客户端。如果客户端一方是恶意的，那么它就可以使用这些凭据，在授权服务器处冒充用户。

这种行为可能出乎开发者的意料，但在 [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 第 15.4.8 节中已有定义。该状态代码不要求用户代理将 POST 请求重写为 GET 请求，从而在 POST 请求内容中删除表单数据。

在 HTTP [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 中，只有状态码 303 明确地将 HTTP POST 方法强制重写为 HTTP GET 方法。对于其它所有状态码，包括流行使用的 302，用户代理都可以选择不将 POST 请求重写为 GET 请求，从而将用户凭据暴露给客户端。（然而实际上，大多数用户代理只会在 307 重定向中做出这种行为。）

## 7.6. 确保端点真实性

在与授权端点和令牌端点通信时，强制使用通道安全机制（如 [[RFC8446](https://www.rfc-editor.org/info/rfc8446)]）降低了中间人攻击的风险。详见第 1.5 节。

## 7.7. 凭据预测攻击

授权服务器**必须**防止攻击者预测访问令牌、授权码、刷新令牌、资源所有者的密码以及客户端凭据。

攻击者预测生成令牌（以及其它不该由终端用户处理的凭据）的成功概率**必须**小于或等于 2^(-128)，并且**应该**小于或等于 2^(-160)。

授权服务器**必须**使用其它方法保护用于终端用户的凭据。

## 7.8. 钓鱼攻击

该协议和类似协议的广泛部署，可能导致终端用户对于被重定向到其它网站，然后被要求输入密码的做法感到习以为常。如果终端用户不够谨慎，在输入他们的凭据之前，没有验证这些网站的真实性，攻击者就有可能利用这种做法，窃取资源所有者的密码。

服务提供者应该尝试教导终端用户，告知他们钓鱼攻击带来的风险，并且应该提供一种机制，让终端用户能够轻松确认自己网站的真实性。客户端开发者应该考虑与用户代理交互的方式（例如，外部或嵌入式）的安全影响，以及终端用户验证授权服务器真实性的能力。

更多关于减少钓鱼攻击风险的细节，见第 1.5 节。

## 7.9. 跨站请求伪造

攻击者可能会尝试向受害者设备上合法客户端的重定向 URI 注入请求，例如，使客户端访问由攻击者控制的资源。这是跨站请求伪造（CSRF）攻击的变种。

传统的对策是，客户端在 state 参数中传递一个随机值（也称为 CSRF 令牌），将对重定向 URI 的请求关联到上述的用户代理会话。[[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 第 5.3.5 节详细描述了该对策。code_verifier 参数或 OpenID Connect 的 nonce 值也提供了同样的保护。

在使用 code_verifier 代替 state 或 nonce 进行 CSRF 保护时，以下几点非常重要：

- 客户端必须确保授权服务器支持客户端打算使用的 code_challenge_method。如果授权服务器不支持所请求的方法，那么**必须**转而使用 state 或 nonce 进行 CSRF 保护。
- 如果 state 用于携带应用状态，并且其内容的完整性是一个问题，那么客户端**必须**保护 state 免受篡改和交换。这可以通过将 state 的内容绑定到浏览器会话，以及/或者签名/加密 state 值 [[I-D.bradley-oauth-jwt-encoded-state](https://datatracker.ietf.org/doc/html/draft-bradley-oauth-jwt-encoded-state-09)] 来实现。

因此，授权服务器**必须**提供一种方法，用于检测它支持的code_challenge_method，要么根据 [[RFC8414](https://www.rfc-editor.org/info/rfc8414)] 使用授权服务器的元数据，要么提供一种针对部署的方法来确保或确定支持的方法。

## 7.10. 点击劫持

如 [[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 第 4.4.1.9 节所述，授权请求容易受到点击劫持攻击，也称用户界面伪装。在这种攻击中，攻击者会将授权端点的用户界面嵌入一个无害的环境中。用户认为自己在和无害的环境交互，例如，点击了某个按钮，但却无意中和授权端点的用户界面进行了交互。反之亦然：用户认为自己在和授权端点交互，但却无意中在覆盖在原用户界面上的、攻击者提供的输入框中，输入了密码。点击劫持攻击可以设计得让用户难以察觉，例如使用几乎看不见的 iframe 叠加在其它元素之上。

攻击者可以利用这种载体，获取用户的认证凭据，改变授予给客户端的访问范围，并且可能访问用户的资源。

授权服务器**必须**防止点击劫持攻击。[[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 描述了多种对策，包括使用 X-Frame-Options HTTP 响应头字段，以及 frame-busting JavaScript。此外，授权服务器还**应该**使用 2 级及以上的内容安全策略（CSP）[[CSP-2](https://www.w3.org/TR/CSP2)]。

为了使其有效，必须在授权端点上使用 CSP。如果适用，还必须在用于认证用户和授权客户端的其它端点（如设备授权端点、登录页面、错误页面等）上使用 CSP。这防止了支持 CSP 的用户代理中出现未经授权方的框架。客户端**可以**允许自身以框架形式，出现在重定向端点所使用的来源之外的其他来源中。因此，授权服务器**应该**允许管理员为特定客户端配置允许的来源和/或允许客户动态注册这些来源。

使用了 CSP，授权服务器就可以在单个响应头字段中指定多个来源，并使用灵活的模式对其进行限制（详见 [[CSP-2](https://www.w3.org/TR/CSP2)]）。该标准的第 2 级通过使用限制框架来源的策略（使用 frame-ancestors）和限制允许在 HTML 页面上执行的脚本来源的策略（使用 script-src），提供了一个强大的机制，用于防止点击劫持。下面是这种策略的一个非规范示例：

```http
HTTP/1.1 200 OK
Content-Security-Policy: frame-ancestors https://ext.example.org:8000
Content-Security-Policy: script-src 'self'
X-Frame-Options: ALLOW-FROM https://ext.example.org:8000
...
```

由于某些用户代理不支持 [[CSP-2](https://www.w3.org/TR/CSP2)]，因此该技术**应该**与其它技术结合使用，包括 [[RFC6819](https://www.rfc-editor.org/info/rfc6819)] 中描述的技术，除非授权服务器明确不支持这些传统用户代理。即使在这种情况下，仍然**应该**采用其它应对措施。

## 7.11. 代码注入和输入验证

当输入或其它外部变量在未经消毒的情况下被应用程序使用，并且导致应用程序逻辑被修改时，就会发生代码注入攻击。这可能会允许攻击者访问应用设备或其数据，导致拒绝服务，或引入一系列恶意副作用。

授权服务器和客户端**必须**对接收到的任何值进行消毒（并在可能的情况下进行验证）——特别是 state 和 redirect_uri 参数的值。

## 7.12. 开放式重定向

开放式重定向器是一个端点，它将用户的浏览器转发到从查询参数中获取的任意 URI。这种端点有时会被实现，例如，用于展示一条消息，然后将用户重定向到外部网站，或者将用户重定向回到他们本要访问的 URL，但中途被打断了，例如，登录提醒。

当授权服务器或客户端有一个开放式重定向器时，下面的攻击可能会发生。

### 7.12.1. 客户端作为开放式重定向器

客户端**禁止**暴露它的开放式重定向器。攻击者可能会利用开放式重定向器，生成指向客户端的 URL，并且利用这些 URL 渗透授权码，如 [[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-27)] 第 4.1.1 节所述。另一种滥用开放式重定向器的情况是，生成了看似指向客户端的 URL。这可能会诱使用户相信该 URL，并且在浏览器中跟随该 URL。这可能会被滥用于钓鱼。

为了防止开放式重定向，客户端应该仅当目标 URL 在白名单内，或者请求的来源和完整性可以被认证时，才进行重定向。OWASP [[owasp_redir](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html)] 描述了开放式重定向的对策。

### 7.12.2. 授权服务器作为开放式重定向器

就像客户端一样，攻击者可以试图利用授权服务器（特别是它的 URL）对用户的信任，实施钓鱼攻击。OAuth 授权服务器经常将用户重定向到其它网站（客户端），但必须用安全的方式实现。

第 4.1.2.1 节已经规定了，当 client_id 和 redirect_uri 的组合无效时，授权服务器**禁止**自动重定向用户代理，从而防止了开放式重定向。

然而，攻击者仍然可以利用正确注册的重定向 URI，实施钓鱼攻击。例如，攻击者可以通过客户端动态注册 [[RFC7591](https://www.rfc-editor.org/info/rfc7591)]，注册客户端，然后实施下列攻击之一：

1. 故意发送错误的授权请求，例如，使用无效的范围值，然后引导授权服务器将用户代理重定向到攻击者的钓鱼网站。
2. 故意发送合理的授权请求，但 client_id 和 redirect_uri 由攻击者控制。在用户经过认证后，授权服务器提示用户同意授权请求。如果用户注意到了请求有问题，授权服务器还是会将用户代理重定向到钓鱼网站。在这种情况下，不管用户怎么做，用户代理都会被重定向到钓鱼网站。
3. 故意发送合理的静默授权请求（没有提示），但 client_id 和 redirect_uri 由攻击者控制。在这种情况下，授权服务器会自动将用户代理重定向到钓鱼网站。

授权服务器**必须**采取预防措施，防止这些威胁。授权服务器**必须**始终先认证用户；然后，除非是静默认证，在必要时提醒用户输入凭据；最后，再重定向用户。根据其风险评估策略，授权服务器需要决定它是否能信任重定向 URI。它可以考虑内部进行的 URI 分析，或者通过某些外部服务，评估 URI 背后内容的信誉和可信度，以及重定向 URI 和其它客户端数据的来源。

授权服务器**应该**仅在信任重定向 URI 时，才自动重定向用户代理。如果不信任 URI，那么授权服务器**可以**告知用户，让用户来做出正确决策。

## 7.13. 减少授权服务器混淆攻击

混淆攻击的发生场景是，OAuth 客户端与两台或多台授权服务器交互，并且至少一个授权服务器由攻击者控制。例如，如果攻击者使用动态注册，在他自己的授权服务器上注册客户端，或者某台授权服务器沦陷，那么就会出现这种攻击。

当 OAuth 客户端只能与一台授权服务器交互时，混淆攻击防御不是必需的。然而，在 OAuth 客户端与两台或多台授权服务器交互时，客户端就**必须**防止混淆攻击。下面探讨了两种不同的防御方法。

对于两种防御，客户端都**必须**为每个授权请求存储其发送给的颁发者，将此信息绑定到用户代理，并检查是否从正确的颁发者处接收到了授权响应。客户端**必须**确保后续的访问令牌请求（如果适用）是发送给同一个颁发者。通过相关元数据，颁发者作为流程中使用的授权端点和令牌端点组合的抽象标识符。如果没有可用的颁发者标识符，例如，既没有使用 OAuth 元数据 [[RFC8414](https://www.rfc-editor.org/info/rfc8414)]，又没有使用 OpenID Connect 发现 [[OpenID.Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)]，那么可以使用该元组的不同的唯一标识符，或者元组本身。为了简洁起见，下面将这种部署特定的标识符统一归为颁发者（或颁发者标识符）。

说明：只存储授权服务器的 URL 不足以识别出混淆攻击。攻击者可能将一台未沦陷的授权服务器的授权端点 URL 声明为“他们”的授权服务器 URL，但又声明一个由自己控制的令牌端点。

关于若干种混淆攻击的详细描述，见 [[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-27)] 的第 4.4 节。

### 7.13.1 基于颁发者身份的混淆攻击防御

这种防御要求授权服务器在返回给客户端的授权响应中，发送他的颁发者身份。当接收到授权响应时，客户端**必须**比对接收到的颁发者身份和存储的颁发者身份。如果不匹配，客户端**必须**中止交互。

有多种方式可以将颁发者身份传输给客户端。

- 例如，颁发者信息可以通过可选的响应参数 iss（见第 4.1.2 节）进行传输。
- 当使用 OpenID Connect，并且授权响应中返回了 ID 令牌时，客户端可以评估 ID 令牌中的 iss 声明。

在两种情况下，iss 的值**必须**根据 [[RFC9207](https://www.rfc-editor.org/info/rfc9207)] 进行评估。

虽然这种防御需要使用额外的参数，以传输颁发者信息，但是它比较健壮，并且相对容易实现。

### 7.13.2. 基于唯一重定向 URI 的混淆攻击防御

在这种防御中，客户端**必须**对于每个有交互的颁发者，使用唯一的重定向 URI。

客户端**必须**通过比较颁发者的唯一重定向 URI 和接收到授权响应的 URI，检查授权响应是否从正确的颁发者处接收到。如果不匹配，那么客户端**必须**中止流程。

虽然这种防御建立在现有 OAuth 功能的基础上，但它不能用于客户只注册一次就能使用许多不同颁发者的情况（如某些开放银行方案）。而且，由于它与客户端的注册紧密耦合，这种防御更难以自动部署。

此外，攻击者可能通过使用客户端分配给攻击者的授权服务器的重定向 URI，在“诚实”的授权服务器上注册新客户端，从而规避这种防御所提供的保护。然后，攻击者就可以发起上述攻击，用新创建客户端的客户端 ID 替换原有的客户端 ID。

因此，只有在没有其它选择的情况下，才**应该**使用这种防御方法。
