**目录**

- [1. 简介](#1-简介)
  - [1.1. 角色](#11-角色)
  - [1.2. 协议流程](#12-协议流程)
  - [1.3. 授权许可](#13-授权许可)
    - [1.3.1. 授权码](#131-授权码)
    - [1.3.2. 刷新令牌](#132-刷新令牌)
    - [1.3.3. 客户端凭据](#133-客户端凭据)
  - [1.4. 访问令牌](#14-访问令牌)
    - [1.4.1. 访问令牌的范围](#141-访问令牌的范围)
    - [1.4.2. Bearer 令牌](#142-bearer-令牌)
    - [1.4.3. 发送者约束的访问令牌](#143-发送者约束的访问令牌)
    - [1.5. 通信安全](#15-通信安全)
  - [1.6. HTTP 重定向](#16-http-重定向)
  - [1.7. 互操作性](#17-互操作性)
  - [1.8. 与 OAuth 2.0 的兼容性](#18-与-oauth-20-的兼容性)
  - [1.9. 符号约定](#19-符号约定)

# 1. 简介

OAuth 通过分离客户端与资源所有者的角色，为客户端-服务器认证模型引入了授权层。在 OAuth 中，客户端请求访问由资源所有者控制、由资源服务器托管的资源。客户端不使用资源所有者的凭据来访问受保护的资源，而是获取一个访问令牌，即一种代表了一组特定的访问属性（如范围和生命周期）的凭据。经资源所有者批准，访问令牌由授权服务器颁发给客户端。客户端使用访问令牌来访问由资源服务器托管的受保护资源。

在更老旧、更受限制的客户端-服务器认证模型中，客户端使用资源所有者的凭据，与服务器进行认证，并据此请求某一访问受限的资源（受保护资源）。为了让应用程序访问受限资源，资源所有者需要与应用程序分享他们的凭据。这造成了若干问题和限制：

- 应用程序需要存储资源所有者的凭据以备将来使用，而这一凭据通常是明文密码。
- 服务器需要支持基于密码的认证，而密码有内在的安全弱点。
- 对于资源所有者拥有的受保护资源，应用程序获取了过于宽泛的访问权限。这使得资源所有者无法限制访问的持续时间或访问资源的范围。
- 资源所有者经常在其它无关的服务中使用相同的密码，而不顾最佳的安全实践。这种密码的复用，意味着一项服务的漏洞或泄露，可能会对完全无关的服务产生安全影响。
- 资源所有者无法仅仅撤销对单个第三方应用程序的访问权限，而不撤销对所有第三方应用程序的访问权限。并且，这种撤销行为只能通过更改密码来实现。
- 任何应用程序被攻陷，都会导致终端用户的密码和受该密码保护的所有数据被攻陷。

通过 OAuth，终端用户（资源所有者）可以授权某一打印服务（客户端）访问他们存储在某一照片分享服务（资源服务器）上的受保护的照片，而无需把他们的用户名和密码告诉打印服务。相反，他们直接与某一受照片分享服务信任的服务器（授权服务器）进行认证，后者会颁发打印服务所委托的特定凭据（访问令牌）。

这种关注点的分离，还使得更高级的用户认证方法成为了可能——例如多因素认证，甚至是无密码认证——而无需修改应用程序。由于所有用户认证的逻辑都由授权服务器处理，应用程序不需要考虑任何一种认证机制的实现细节。这使得授权服务器能够全权管理用户认证的策略，并且甚至不需要与应用程序协调，也能够在未来改变这些策略。

这一授权层还能够简化资源服务器判断请求是否被授权的过程。传统上，在认证客户端后，每台资源服务器在每次 API 调用时，都要进行策略评估，以确定客户端是否获得授权。在分布式系统中，要么这些策略需要被同步到所有资源服务器上，要么每台资源服务器都必须调用中央策略服务器来处理请求。而在 OAuth 中，只有在授权服务器创建了新的访问令牌时，才需要进行策略评估。如果访问令牌已经表明了访问被授权，那么资源服务器就不再需要进行策略评估，只需要验证访问令牌即可。这种简化既适用于应用程序代表资源所有者的情况，也适用于应用程序代表自己的情况。

OAuth 是授权协议，而非认证协议。访问令牌代表了授予客户端的授权。一种常见的做法是，客户端向专门的 API 提供访问令牌，API 返回资源所有者的用户标识符，然后客户端再将 API 返回的结果作为认证的代理。这种做法不属于 OAuth 的标准或安全考量，资源所有者也未必考虑过这种做法。在采取这种做法前，实现者应该仔细查阅资源服务器的文档。

该规范被设计为与 HTTP（[[RFC9110](https://www.rfc-editor.org/info/rfc9110)]）一起使用。在除 HTTP 以外的协议上使用 OAuth 超出了该规范的范围。

自 2012 年 10 月 OAuth 2.0 授权框架（[[RFC6749](https://www.rfc-editor.org/info/rfc6749)]）发布以来，它被这些文档所更新：用于本机应用程序的 OAuth 2.0（[[RFC8252](https://www.rfc-editor.org/info/rfc8252)]）、OAuth 安全当前最佳实践（[[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24)]）以及用于浏览器应用程序的 OAuth 2.0（[[I-D.ietf-oauth-browser-based-apps](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps-15)]）。OAuth 2.0 授权框架：Bearer 令牌使用（[[RFC6750](https://www.rfc-editor.org/info/rfc6750)]）也被（[[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24)]）所更新。该规范结合了上述所有文档的信息，并且移除了（[[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24)]）中已被发现不安全的功能。

## 1.1. 角色

OAuth 定义了四种角色：

**“资源所有者”：** 能够授予对受保护资源的访问权限的实体。当资源所有者是个人时，称其为终端用户。有时简称其为“RO”。

**“资源服务器”：** 托管受保护资源的服务器，能够根据访问令牌接受并响应对受保护资源的请求。通常通过 API 访问资源服务器。有时简称其为“RS”。

**“客户端”：** 代表了资源所有者，并在其授权下，请求受保护资源的应用程序。这里的术语“客户端”不隐含任何具体的实现细节（例如应用程序是在服务器、桌面还是其他设备上运行）。

**“授权服务器”：** 在成功认证资源所有者，并且获得其授权后，给客户端颁发访问令牌的服务器。有时简称其为“AS”。

授权服务器和资源服务器之间的交互超出了该规范的范围，但已有若干扩展提供了两者的互操作性选项。授权服务器可以和资源服务器是同一台服务器，也可以是一个单独的实体。单个授权服务器可以颁发被多个资源服务器接受的访问令牌。

## 1.2. 协议流程

```
+--------+                               +---------------+
|        |--(1)- Authorization Request ->|   Resource    |
|        |                               |     Owner     |
|        |<-(2)-- Authorization Grant ---|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(3)-- Authorization Grant -->| Authorization |
| Client |                               |     Server    |
|        |<-(4)----- Access Token -------|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--(5)----- Access Token ------>|    Resource   |
|        |                               |     Server    |
|        |<-(6)--- Protected Resource ---|               |
+--------+                               +---------------+
```

<p align="center">图 1：抽象的协议流程</p>

抽象的 OAuth 2.1 流程如图 1 所示。它描述了四种角色之间的交互，包括以下步骤：

1. 客户端请求资源所有者的授权。授权请求可以直接发送给资源所有者（如图所示）；或者一种更好的做法是，通过作为中介的授权服务器来间接发送。
2. 客户端接收到授权许可。后者是一种代表了资源所有者授权的凭据，其表现形式可以使用该规范定义的授权许可类型，或者是扩展的许可类型。授权许可的类型一方面取决于客户端请求授权的方法，另一方面也取决于授权服务器支持的类型。
3. 客户端与授权服务器进行认证，并展示授权许可，来请求访问令牌。
4. 授权服务器认证客户端，并验证授权许可。如果有效，就颁发访问令牌。
5. 客户端展示访问令牌以进行认证，来请求资源服务器上的受保护资源。
6. 资源服务器验证访问令牌。如果有效，就为请求提供服务。

客户端从资源所有者处获取授权许可（如步骤（1）和（2）所示）的首选方法，是使用授权服务器作为中介，如第 4.1 节的图 3 所示。

## 1.3. 授权许可

授权许可代表了资源所有者（允许访问他拥有的受保护资源）的授权，客户端使用其获取访问令牌。该规范定义了三种许可类型，即授权码、刷新令牌和客户端凭据，以及用于定义额外类型的扩展机制。

### 1.3.1. 授权码

授权码是一种临时凭据，用于获取访问令牌。客户端不直接从资源所有者处请求授权，而是将资源所有者（通过其用户代理）定向到授权服务器；后者再将其定向回到客户端，并附上授权码。之后，客户端就可以使用授权码交换访问令牌。

在将资源所有者定向回到客户端并附上授权码之前，授权服务器认证资源所有者，并且可能会征求资源所有者的同意，或者告知他们客户端的请求。由于资源所有者只与授权服务器进行认证，资源所有者的凭据永远不会被分享给客户端。客户端也无需了解其它任何认证步骤，例如多因素认证或委托账户。

授权码提供了一些重要的安全优势，例如能够认证客户端，以及能够直接将访问令牌传输给客户端，而无需经过资源所有者的用户代理，从而避免了潜在的泄露，其中也包括泄露给资源所有者。

### 1.3.2. 刷新令牌

刷新令牌是用于获取访问令牌的凭据。刷新令牌可以由授权服务器颁发给客户端，并在现有的访问令牌失效或过期时，用于获取新的访问令牌，或者获取额外的、范围一致或更小的访问令牌（与资源所有者所授权的相比，访问令牌可以有更短的寿命、更少的权限）。刷新令牌的颁发是可选的，由授权服务器决定，并且可以根据客户端的属性、请求的属性、授权服务器的内置策略或任何其它依据来颁发。如果授权服务器选择颁发刷新令牌，刷新令牌就会与访问令牌一并颁发（例如图 2 的步骤（2）所示）。

刷新令牌是代表了资源所有者授予客户端的授权的字符串。这一字符串被视为对客户端不透明。刷新令牌可能是用于获取授权信息的标识符，也可能其本身就编码了这一信息。与访问令牌不同的是，刷新令牌旨在仅被用于授权服务器，而永远不发送给资源服务器。

```
+--------+                                           +---------------+
|        |--(1)------- Authorization Grant --------->|               |
|        |                                           |               |
|        |<-(2)----------- Access Token -------------|               |
|        |               & Refresh Token             |               |
|        |                                           |               |
|        |                            +----------+   |               |
|        |--(3)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(4)- Protected Resource --| Resource |   | Authorization |
| Client |                            |  Server  |   |     Server    |
|        |--(5)---- Access Token ---->|          |   |               |
|        |                            |          |   |               |
|        |<-(6)- Invalid Token Error -|          |   |               |
|        |                            +----------+   |               |
|        |                                           |               |
|        |--(7)----------- Refresh Token ----------->|               |
|        |                                           |               |
|        |<-(8)----------- Access Token -------------|               |
+--------+           & Optional Refresh Token        +---------------+
```

<p align="center">图 2：刷新过期的访问令牌</p>

图 2 所示的流程包括以下步骤：

1. 客户端与授权服务器进行认证，并展示授权许可，来请求访问令牌。
2. 授权服务器认证客户端，并验证授权许可。如果有效，就颁发访问令牌和可选的刷新令牌。
3. 客户端展示访问令牌，来请求资源服务器上的受保护资源。
4. 资源服务器验证访问令牌。如果有效，就为请求提供服务。
5. 重复步骤（3）和（4），直到访问令牌过期。如果客户端知道访问令牌已过期，它就跳转到步骤（7）；否则，它就再次请求受保护资源。
6. 由于访问令牌无效，资源服务器返回无效令牌错误。
7. 客户端展示刷新令牌，并提供客户端的认证信息（如果它被颁发过凭据），来请求新的访问令牌。客户端的认证要求取决于客户端类型和授权服务器的策略。
8. 授权服务器认证客户端，并验证刷新令牌。如果有效，就颁发新的访问令牌（和可选的新的刷新令牌）。

### 1.3.3. 客户端凭据

当授权范围仅限于由客户端控制的受保护资源时，或者仅限于与授权服务器预先协定好的受保护资源时，客户端凭据，或者其它形式的客户端认证信息（例如 [[RFC7523](https://www.rfc-editor.org/info/rfc7523)] 中描述的用于给 JWT 签名的私钥），可以用作一种授权许可。当客户端根据与授权服务器预先协定好的授权，请求访问受保护资源时，客户端凭据将被使用。

## 1.4. 访问令牌

访问令牌是用于访问受保护资源的凭据，是代表了颁发给客户端的授权的字符串。

即使这一字符串具有某种结构，它也被视为对客户端不透明。客户端**禁止**期望能够解析访问令牌的值。授权服务器不必采用某种一致的访问令牌编码或格式，除了需要满足资源服务器的期望。

访问令牌代表了特定的访问范围和访问持续时间。这种范围和时间由资源所有者授予许可，并由资源服务器和授权服务器执行。

根据授权服务器的具体实现，令牌字符串可能被资源服务器用来获取授权信息，或者其本身就以某种可验证的方式包含了这些授权信息（例如包含了已签名的数据负载的令牌字符串）。令牌检查 [[RFC7662](https://www.rfc-editor.org/info/rfc7662)] 是令牌获取机制的一个示例。在该机制中，资源服务器访问授权服务器的某个端点，来验证客户端展示的令牌。访问令牌的 JWT 形式 [[RFC9068](https://www.rfc-editor.org/info/rfc9068)] 则是结构化令牌格式的一个示例。这种方法将访问令牌的数据编码并签名，成为 JSON Web 令牌 [[RFC7519](https://www.rfc-editor.org/info/rfc7519)]。

为了让客户端使用访问令牌，可能需要额外的认证凭据，这超出了该规范的范围。这些凭据通常被称为发送者约束的访问令牌，例如 DPoP [[RFC9449](https://www.rfc-editor.org/info/rfc9449)] 和 mTLS [[RFC8705](https://www.rfc-editor.org/info/rfc8705)]。

访问令牌提供了一层抽象，用资源服务器所能理解的单一令牌，替代了各种授权结构（例如用户名和密码）。这种抽象使得颁发的访问令牌能够比用于获取它们的授权许可更有限制性，并且消除了资源服务器理解多种认证方法的需要。

根据资源服务器的安全要求，访问令牌可以采用不同的格式、结构以及使用方法（例如加密属性）。访问令牌的属性，以及用于访问受保护资源的方法，可以在该规范之外进行延申。

访问令牌（以及访问令牌的任何机密属性）**必须**在传输和存储时保持机密，并且只能在授权服务器、该访问令牌对其有效的资源服务器和该访问令牌被颁发给的客户端之间共享。

授权服务器**必须**保证访问令牌无法被未授权方生成、修改或者预测，并以此创建有效的访问令牌。

### 1.4.1. 访问令牌的范围

被颁发访问令牌的客户端，相比起授予它访问权限的用户来说，权限更少。这种令牌被称为有限“范围”的访问令牌。授权服务器和资源服务器可以使用这种范围机制来限制某一客户端可以访问的资源类型或访问级别。例如，客户端可能只需要对用户资源的“读取”访问权限，而不需要更新资源。因此，客户端可以请求由授权服务器定义的只读范围，然后获取一个无法用于更新资源的访问令牌。这需要授权服务器和资源服务器之间的协调。授权服务器提供给客户端请求特定范围的能力，并将这些范围与颁发给客户端的访问令牌关联起来。然后，在面对有限范围的访问令牌时，资源服务器负责执行这些范围限制。

为了请求有限范围的访问令牌，客户端根据使用的授权类型，在授权或令牌端点使用范围请求参数。授权服务器则使用范围响应参数，来告知客户端颁发的访问令牌的范围。

范围参数的值表示为以空格分隔的、区分大小写的字符串列表。这些字符串由授权服务器定义。如果值包含多个以空格分隔的字符串，它们的顺序不重要，每个字符串都会将一个额外的访问范围添加到所请求的范围中。

```abnf
scope       = scope-token *( SP scope-token )
scope-token = 1*( %x21 / %x23-5B / %x5D-7E )
```

根据授权服务器的策略或资源所有者的指示，授权服务器**可以**完全或部分忽略客户端请求的范围。如果颁发的访问令牌的范围与客户端请求的范围不同，授权服务器**必须**在令牌响应（第3.2.3节）中包含范围响应参数，以告知客户端实际授予的范围。

如果客户端在请求授权时省略了范围参数，授权服务器**必须**要么使用预定义的默认值处理请求，要么拒绝请求并显示范围无效。授权服务器**应该**记录其范围要求和默认值（如果有定义）。

### 1.4.2. Bearer 令牌

Bearer 令牌是一种安全令牌，持有该令牌的任何一方（“持有者”）都能够以任何其他持有者能够使用该令牌的任何方式来使用该令牌。使用 Bearer 令牌不需要持有者证明其拥有加密密钥材料（持有证明）。

Bearer 令牌可以使用持有证明规范进行增强，例如 DPoP [[RFC9449](https://www.rfc-editor.org/info/rfc9449)] 和 mTLS [[RFC8705](https://www.rfc-editor.org/info/rfc8705)]，以提供持有证明的特性。

为了防止访问令牌泄露，客户端和资源服务器之间的通信交互**必须**使用第 1.5 节中描述的机密性和完整性保护。

Bearer 令牌没有特定的结构要求或格式要求。如果 Bearer 令牌是对授权信息的引用，那么这样的引用**必须**对攻击者来说是不可预测的，例如使用足够长的加密随机字符串。如果 Bearer 令牌使用编码机制，在令牌本身中包含授权信息，那么访问令牌**必须**具有足够的完整性保护，以防止令牌被修改。访问令牌的 JWT 形式 [[RFC9068](https://www.rfc-editor.org/info/rfc9068)] 是访问令牌的编码和签名机制的一个示例。

### 1.4.3. 发送者约束的访问令牌

发送者约束的访问令牌将访问令牌的使用绑定到特定的发送方。该发送方有义务展示其知道某个密钥，作为接收方（例如资源服务器）接受该访问令牌的前置条件。

授权服务器和资源服务器**应该**使用发送者约束的访问令牌的机制，例如 OAuth 持有证明展示（DPoP）[[RFC9449](https://www.rfc-editor.org/info/rfc9449)] 或 OAuth 2.0 的双向 TLS（mTLS）[[RFC8705](https://www.rfc-editor.org/info/rfc8705)]。请参考 [[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24)] 的第 4.10.1 节，以防止被盗和泄露的访问令牌的滥用。

**推荐**在客户端和资源服务器之间使用端到端的 TLS。如果需要在中间代理处终止 TLS流量，请参考 [[I-D.ietf-oauth-security-topics](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-24)] 的第 4.13 节获取更多安全建议。

### 1.5. 通信安全

该规范的实现**必须**使用一种机制来提供通信的认证、完整性和机密性，例如传输层安全性协议 [[RFC8446](https://www.rfc-editor.org/info/rfc8446)]，以保护内容或头部字段中的明文凭据和令牌的交换，防止窃听、篡改和消息伪造（示例见第 2.4.1 节、第 7.5.1 节、第 3.2 节和第 1.4.2 节）。

OAuth 的 URL **必须**使用 https 协议，除了回环接口重定向 URI **可以**使用 http 协议。在使用 https 时，**必须**根据 [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 检查 TLS 证书。截至本文撰写时，TLS 的最新版本是 1.3 版本 [[RFC8446](https://www.rfc-editor.org/info/rfc8446)]。

该规范的实现也**可以**支持满足其安全要求的其他传输层安全机制。

TLS 版本和算法的辨识超出了该规范的范围。关于传输层安全的最新建议见 [[BCP195](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#BCP195)]。证书验证和其他安全考量见相关规范。

## 1.6. HTTP 重定向

该规范大量使用了 HTTP 重定向，其中的客户端或授权服务器会将资源所有者的用户代理定向到别处。虽然该规范中的示例使用的是 HTTP 302 状态码，但是任何其它的重定向方法，除了 HTTP 307，只要在用户代理中可用，都是被允许的，并且被视为实现细节。详细描述见第 7.5.4 节。

## 1.7. 互操作性

OAuth 2.1 提供了内容丰富的授权框架，以及定义明确的安全属性。

该规范在一些必需组件上部分或完全未定义（例如客户端注册、授权服务器功能、端点发现）。其中的一些行为在可选扩展中进行了定义，具体实现可以选择使用这些扩展，例如：

- [[RFC8414](https://www.rfc-editor.org/info/rfc8414)]：授权服务器的元数据，定义了一个端点，让客户端查询与特定 OAuth 服务器交互的必要信息。
- [[RFC7591](https://www.rfc-editor.org/info/rfc7591)]：客户端动态注册，提供了一种机制，以编程方式在授权服务器上注册客户端。
- [[RFC7592](https://www.rfc-editor.org/info/rfc7592)]：客户端动态管理，提供了一种机制，更新动态注册的客户端的信息。
- [[RFC7662](https://www.rfc-editor.org/info/rfc7662)]：令牌检查，定义了一种机制，让资源服务器获取访问令牌的相关信息。

请参考附录 C，以了解该规范发布时已知的扩展列表。

## 1.8. 与 OAuth 2.0 的兼容性

OAuth 2.1 在兼容 OAuth 2.0 的基础上，采用了当前已知最佳实践中的一系列扩展和限制。具体来说，OAuth 2.0 核心中未提及的一些功能，例如 PKCE，在 OAuth 2.1 中是必需的。此外，OAuth 2.0 中可用的一些功能，例如隐式或资源所有者凭据许可类型，在 OAuth 2.1 中不再提及。另外，OAuth 2.0 中允许的一些行为，在 OAuth 2.1 中得到了限制，例如 OAuth 2.1 要求重定向 URI 字符串必须严格匹配。

更多和 OAuth 2.0 的区别的细节见第 10 节。

## 1.9. 符号约定

该文档中的关键词“**必须**”、“**禁止**”、“**必需**”、“**要**”、“**不要**”、“**应该**”、“**不应该**”、“**推荐**”、“**不推荐**”、“**可以**”以及“**可选**”将按照 BCP 14 [[RFC2119](https://www.rfc-editor.org/info/rfc2119)] [[RFC8174](https://www.rfc-editor.org/info/rfc8174)] 中的描述来解释，当且仅当这些词以如上所示的全部大写形式出现。

> [!NOTE]
>
> 译者注：由于中文无大小写区分，该翻译版本将使用加粗文本代替大写。例如，“**必须**”对应 “MUST”，按照 BCP 14 中对 “MUST” 的描述来解释。

该规范使用了 [[RFC5234](https://www.rfc-editor.org/info/rfc5234)] 中的增强巴科斯范式（ABNF）表示法。此外，URI-reference 规则来自“统一资源标识符（URI）：通用语法” [[RFC3986](https://www.rfc-editor.org/info/rfc3986)]。

与安全相关的术语应按 [[RFC4949](https://www.rfc-editor.org/info/rfc4949)] 中定义的意义理解。这些术语包括但不限于“攻击”、“认证”、“授权”、“证书”、“机密性”、“凭证”、“加密”、“身份”、“签名”、“信任”和“验证”。

术语“内容”应按 [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 第 6.4 节中描述的方式解释。

术语“用户代理”应按 [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] 第 3.5 节中描述的方式解释。

除非另有说明，所有协议参数的名称和值都区分大小写。
